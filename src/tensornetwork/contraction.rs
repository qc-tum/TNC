use std::{collections::HashMap, ops::RangeBounds};

use log::debug;
use tetra::{contract, Tensor as DataTensor};

use crate::{
    gates::load_gate,
    io::load_data,
    tensornetwork::Tensor,
    types::{ContractionIndex, EdgeIndex, Vertex},
};

use super::tensordata::TensorData;

/// Fully contracts a series of [`Tensor`] objects based on a given contraction path using repeated SSA format.
///
/// # Arguments
///
/// * `tn` - [`Tensor`] to be contracted
/// * `contract_path` - slice of [`ContractionIndex`], indicating contraction path. See `BranchBound` for details on `contract_path` format.
///
/// # Examples
///
/// ```
/// # extern crate tensorcontraction;
/// # use tensorcontraction::{
///     contractionpath::paths::{branchbound::BranchBound, CostType, OptimizePath},
///     random::tensorgeneration::random_tensor_network_with_rng,
///     tensornetwork::tensor::Tensor,
///     tensornetwork::contraction::contract_tensor_network,
/// };
/// # use rand::rngs::StdRng;
/// # use rand::SeedableRng;
///
/// let mut r = StdRng::seed_from_u64(42);
/// let mut r_tn = random_tensor_network_with_rng(2, 3, &mut r);
/// let mut opt = BranchBound::new(&r_tn, None, 20f64, CostType::Flops);
/// opt.optimize_path();
/// let opt_path = opt.get_best_replace_path();
/// contract_tensor_network(&mut r_tn, &opt_path);
/// ```
pub fn contract_tensor_network(tn: &mut Tensor, contract_path: &[ContractionIndex]) {
    debug!("Contracting tensor");
    for contract_index in contract_path {
        match contract_index {
            ContractionIndex::Pair(i, j) => {
                tn.contract_tensors(*i, *j);
            }
            ContractionIndex::Path(i, inner_contract_path) => {
                contract_tensor_network(tn.get_mut_tensor(*i), inner_contract_path);
                tn.update_tensor_edges(&mut tn.tensor(*i).clone());
            }
        }
    }

    tn.tensors.retain(|x| {
        !x.tensor_data().approx_eq(&TensorData::Uncontracted, 1e-12) || x.is_composite()
    });
    if tn.tensors.len() == 1 {
        tn.set_legs(tn.tensors[0].legs().clone());
        let tmp_data = tn.tensor(0).tensor_data().to_owned();
        tn.tensors.drain(0..);
        tn.set_tensor_data(tmp_data);
    }
}

pub(crate) trait TensorContraction {
    /// Internal method to permute tensor
    fn get_mut_tensor(&mut self, i: usize) -> &mut Tensor;
    fn get_mut_edges(&mut self) -> &mut HashMap<EdgeIndex, Vec<Vertex>>;
    fn get_data(&self) -> DataTensor;
    fn swap(&mut self, i: usize, j: usize);
    fn drain<R>(&mut self, range: R)
    where
        R: RangeBounds<usize>;
    fn contract_tensors(&mut self, tensor_a_loc: usize, tensor_b_loc: usize);
}

impl TensorContraction for Tensor {
    fn get_mut_tensor(&mut self, i: usize) -> &mut Tensor {
        &mut self.tensors[i]
    }

    // Internal method to update edges
    fn get_mut_edges(&mut self) -> &mut HashMap<EdgeIndex, Vec<Vertex>> {
        &mut self.edges
    }

    /// Getter for underlying raw data
    fn get_data(&self) -> DataTensor {
        match &*self.tensor_data() {
            TensorData::File(filename) => load_data(filename).unwrap(),
            TensorData::Gate((gatename, angles)) => load_gate(gatename, angles),
            TensorData::Matrix(rawdata) => rawdata.clone(),
            TensorData::Uncontracted => panic!("Cannot get data from uncontracted/empty tensor"),
        }
    }

    // Internal method to swap tensors
    fn swap(&mut self, i: usize, j: usize) {
        self.tensors.swap(i, j);
    }

    /// Drains the `tensor` vector. Mainly used to clear data after contraction.
    fn drain<R>(&mut self, range: R)
    where
        R: RangeBounds<usize>,
    {
        self.tensors.drain(range);
    }

    fn contract_tensors(&mut self, tensor_a_loc: usize, tensor_b_loc: usize) {
        let tensor_a = std::mem::take(&mut self.tensors[tensor_a_loc]);
        let tensor_b = std::mem::take(&mut self.tensors[tensor_b_loc]);

        let tensor_a_legs = tensor_a.legs();
        let tensor_b_legs = tensor_b.legs();
        let mut tensor_symmetric_difference = &tensor_b ^ &tensor_a;

        let edges = self.get_mut_edges();
        for leg in tensor_b_legs {
            edges.entry(*leg).and_modify(|e| {
                e.retain(|v| {
                    if let &Vertex::Closed(tensor_loc) = v {
                        tensor_loc != tensor_a_loc
                    } else {
                        true
                    }
                });
                for vertex in e.iter_mut() {
                    if let Vertex::Closed(tensor_loc) = vertex {
                        if *tensor_loc == tensor_b_loc {
                            *vertex = Vertex::Closed(tensor_a_loc);
                        }
                    }
                }
            });
            edges.retain(|_, edge| edge != &vec![Vertex::Closed(tensor_a_loc)]);
        }

        let out_indices = tensor_symmetric_difference
            .legs
            .iter()
            .map(|e| *e as u32)
            .collect::<Vec<_>>();
        let a_indices = tensor_a_legs
            .iter()
            .map(|e| *e as u32)
            .collect::<Vec<u32>>();
        let b_indices = tensor_b_legs
            .iter()
            .map(|e| *e as u32)
            .collect::<Vec<u32>>();

        tensor_symmetric_difference.set_tensor_data(TensorData::Matrix(contract(
            &out_indices,
            &a_indices,
            &tensor_a.get_data(),
            &b_indices,
            &tensor_b.get_data(),
        )));
        self.tensors[tensor_a_loc] = tensor_symmetric_difference;
    }
}

#[cfg(test)]
mod tests {
    use super::contract_tensor_network;
    use crate::{
        path,
        tensornetwork::{
            contraction::TensorContraction, create_tensor_network, tensor::Tensor,
            tensordata::TensorData,
        },
        types::Vertex,
    };

    use num_complex::Complex64;
    use std::collections::HashMap;
    use tetra::Layout;

    fn setup() -> (
        Vec<Complex64>,
        Vec<Complex64>,
        Vec<Complex64>,
        Vec<Complex64>,
    ) {
        let d1 = [
            0.69469607, 0.03142814, 0.56333184, 0.12908922, 0.68881492, 0.38906653, 0.28704775,
            0.66259172, 0.03017098, 0.0216769, 0.13239795, 0.56624022, 0.60589695, 0.52471058,
            0.08573655, 0.06819372, 0.1568983, 0.41559434, 0.6708583, 0.60417368, 0.98723314,
            0.25018858, 0.14947663, 0.70206464, 0.49755784, 0.50813521, 0.54859423, 0.62646753,
            0.95172281, 0.12807469, 0.56603429, 0.05893249, 0.64737241, 0.04312631, 0.80191274,
            0.17439514, 0.00265264, 0.4052311, 0.91152868, 0.88411605, 0.8787456, 0.88505868,
        ]
        .iter()
        .map(|e| Complex64::new(*e, 0.0))
        .collect();

        let d2 = [
            0.09328754, 0.56783732, 0.16813387, 0.82429821, 0.0184785, 0.73521183, 0.56154307,
            0.36866055, 0.93516298, 0.66265138, 0.75256279, 0.46568749, 0.14677414, 0.24352534,
            0.42248108, 0.4729148, 0.98754226, 0.65741335, 0.71002821, 0.36600333, 0.68610491,
            0.05782579, 0.18485907, 0.94518584, 0.95895765, 0.85841239, 0.05705296, 0.09616524,
            0.63222811, 0.87366903, 0.90875357, 0.47705938, 0.65134858, 0.6608632, 0.95581392,
            0.32332593, 0.53788954, 0.903023, 0.40153079, 0.37487737, 0.30883193, 0.53174817,
            0.39644565, 0.25535147, 0.58535347, 0.77200294, 0.86162035, 0.75814678, 0.72907822,
            0.19955574, 0.18811225, 0.26336036, 0.15323682, 0.26735153, 0.55806485, 0.05887273,
            0.18610468, 0.50636222, 0.45368943, 0.42390405, 0.96522828, 0.84946421, 0.40025282,
            0.19881981, 0.02848654, 0.33727215, 0.95483207, 0.77974469, 0.31792446, 0.39641724,
            0.18105829, 0.17672455, 0.93845113, 0.06969526, 0.02687802, 0.89507515, 0.48635865,
            0.32632963, 0.30049458, 0.097193, 0.98697788, 0.61149565, 0.00866831, 0.71612395,
            0.82291458, 0.49291276, 0.61479999, 0.94664182, 0.4173764, 0.99885288, 0.797537,
            0.11157382, 0.71116417, 0.49948545, 0.99517939, 0.14450441, 0.51148864, 0.35196431,
            0.62919375, 0.35710482, 0.51206311, 0.20117422, 0.88595471, 0.55022357, 0.74170559,
            0.29588465, 0.93177878, 0.25674534, 0.77183918, 0.46184645, 0.48719714, 0.62120151,
            0.50764396, 0.78361974, 0.65953757, 0.20511562, 0.73759098, 0.14039605, 0.83019634,
            0.8332694, 0.55324321, 0.10042969, 0.18699679, 0.18950935, 0.89248192, 0.74924386,
            0.92748739, 0.80220305, 0.47501941, 0.26003983, 0.95522559, 0.91094124, 0.6795759,
            0.41454924, 0.80801303, 0.59779671, 0.51192525, 0.91462506, 0.92084146, 0.61720142,
            0.57376556, 0.24997149, 0.57329336, 0.43957024, 0.50238366, 0.67373356, 0.11259408,
            0.37683318, 0.49300396, 0.6711206, 0.94882965, 0.59395913, 0.05114786, 0.73600206,
            0.00601697, 0.5727972, 0.67090141, 0.58077019, 0.64640978, 0.55276303, 0.06095278,
            0.07539359, 0.17735247, 0.82562252, 0.78428553, 0.1906632, 0.33509431, 0.42012132,
            0.00159857, 0.60167655, 0.24232731, 0.83693469, 0.03338013, 0.85122908, 0.40059668,
            0.71621368, 0.34265388, 0.09638051, 0.64427604, 0.23733484, 0.56653551, 0.52411397,
            0.00628771, 0.57258058, 0.16022726, 0.36959163, 0.75623427, 0.58954677, 0.82969614,
            0.87791391, 0.81419296, 0.9083103, 0.02033065, 0.33228088, 0.6885901, 0.70155266,
            0.41101974, 0.15976186, 0.23377142, 0.06092987, 0.45264005, 0.2132634, 0.09463183,
            0.29559498, 0.90050621, 0.90966579, 0.33135194, 0.75781385, 0.89580607, 0.89514179,
            0.56557729, 0.08695989, 0.64372738, 0.15244104, 0.61556173, 0.43501657, 0.83772869,
            0.95057826, 0.74261719, 0.79065485, 0.11257079, 0.40928239, 0.83167007, 0.89305546,
            0.38080999, 0.64519961, 0.86476415, 0.81232636, 0.52187504, 0.9641269, 0.87137541,
            0.33997589, 0.5117147, 0.97633497, 0.17706302, 0.72655448, 0.36950375, 0.73625114,
            0.99500737, 0.9711593, 0.88231438, 0.00364066, 0.63363962, 0.77629796, 0.76189465,
            0.79594656, 0.06046632, 0.37121335, 0.11968514, 0.34248849, 0.04004532, 0.12645287,
            0.27779065, 0.10250479, 0.24468091, 0.13638938, 0.3328005, 0.84108116, 0.13515933,
            0.65145451, 0.4327036, 0.05269428, 0.9111833, 0.69159617, 0.14994096, 0.79117789,
            0.78700038, 0.16870521, 0.78504774, 0.44292063, 0.62066272, 0.81990975, 0.9322563,
            0.28132287, 0.21205641, 0.7865617, 0.61846373, 0.8919656, 0.87968058, 0.27411728,
            0.38383478, 0.70716565, 0.2629087, 0.67097425, 0.69508973, 0.11427584, 0.92469918,
            0.69439856, 0.67802797, 0.85167929, 0.31096221, 0.92851952, 0.20776057, 0.91726347,
            0.90551286, 0.24317468, 0.48989766, 0.57365687, 0.56664079, 0.37988123, 0.84965442,
            0.04234216, 0.72334513, 0.90954789, 0.35181637, 0.64300879, 0.78047689, 0.88886375,
            0.66392189, 0.71558052, 0.33957753, 0.86017955, 0.24987067, 0.75239371, 0.846215,
            0.80888273, 0.25652923, 0.47976616, 0.71021803, 0.25107151, 0.25820616, 0.65540941,
            0.05381956, 0.31208421, 0.80435833, 0.51970853, 0.92648614, 0.93166913, 0.30201433,
            0.58696402, 0.73332323, 0.389746, 0.40119842, 0.93395815, 0.47877774, 0.61972036,
        ]
        .iter()
        .map(|e| Complex64::new(*e, 0.0))
        .collect();

        let d3 = [
            0.42667703, 0.48457094, 0.68925937, 0.99198568, 0.55416889, 0.38235533, 0.23278915,
            0.35852096, 0.58649561, 0.93958456, 0.64993388, 0.89260841, 0.50899537, 0.45536893,
            0.25893103, 0.61086187, 0.98899915, 0.91573474, 0.19398411, 0.68390863, 0.39154508,
            0.73696751, 0.5698224, 0.78365831, 0.46399883, 0.96999598, 0.96014711, 0.72481088,
            0.30197295, 0.32362527, 0.85744741, 0.03117345, 0.99394162, 0.73509025, 0.02588929,
            0.79422479, 0.19915962, 0.57046363, 0.74970349, 0.92350756, 0.90096793, 0.63684391,
            0.07446369, 0.25514523, 0.97320958, 0.87981084, 0.4379634, 0.63565715, 0.83553603,
            0.3833003, 0.0772783, 0.16907803, 0.15863019, 0.04340611, 0.15821493, 0.11871337,
            0.9943052, 0.24349509, 0.13325565, 0.15391281, 0.01091549, 0.28614178, 0.41929479,
            0.74795668, 0.40158558, 0.96101644, 0.49369888, 0.63394661, 0.80317387, 0.52994169,
            0.66743804, 0.76277137, 0.25734803, 0.90787102, 0.86028783, 0.9712097, 0.79091853,
            0.97385292, 0.28053365, 0.21851811, 0.21683468, 0.89221896, 0.14093243, 0.5011467,
            0.04057924, 0.2620503, 0.97840279, 0.35671425, 0.07766314, 0.38162112, 0.88516118,
            0.74285925, 0.86502545, 0.86329524, 0.59698018, 0.41562044, 0.16286828, 0.24323371,
            0.00842274, 0.19534713, 0.83349213, 0.89453333, 0.8861164, 0.8331781, 0.72101998,
            0.00771226, 0.21253237, 0.882532, 0.07932374, 0.59678746, 0.04757306, 0.71880735,
            0.91201475, 0.51059997, 0.51537244, 0.24251543, 0.80763707, 0.75864631, 0.37702641,
            0.79754793,
        ]
        .iter()
        .map(|e| Complex64::new(*e, 0.0))
        .collect();

        let dout = [
            21.12662191,
            22.54781684,
            19.14112552,
            21.50383642,
            20.41325586,
            21.21790454,
            19.02018308,
            19.80617065,
            18.14298459,
            19.23444656,
            22.09757373,
            23.84187648,
            20.99919352,
            21.00826462,
            17.48069436,
            20.77190844,
            18.61067063,
            20.64907039,
            17.89339839,
            19.46748844,
            18.55191736,
            18.47989775,
            21.51424258,
            23.15271771,
            21.58618595,
            21.87267004,
            19.59396099,
            22.66100042,
            19.69575675,
            21.82218509,
            19.89800678,
            21.31436564,
            19.46194771,
            19.86700794,
            22.58850997,
            24.51772651,
            22.31452844,
            23.62575299,
            20.01337021,
            22.48410562,
            21.13354029,
            22.92646174,
            20.28317164,
            20.82815715,
            19.11679716,
            21.63729977,
            23.81438329,
            25.89513636,
            25.95290253,
            27.8205038,
            23.56074292,
            27.02466869,
            24.12486376,
            26.50415702,
            24.02478861,
            25.81369869,
            22.49520341,
            24.56743911,
            26.9066631,
            30.23243803,
        ]
        .iter()
        .map(|e| Complex64::new(*e, 0.0))
        .collect();

        (d1, d2, d3, dout)
    }

    fn intermediate_data() -> (Vec<Complex64>, Vec<Complex64>) {
        let d12 = vec![
            0.99261966, 1.06328268, 1.562838, 1.66050845, 1.09621891, 2.07681017, 1.16075957,
            1.11633733, 1.46343431, 1.45860872, 1.70314939, 1.90707199, 1.30179362, 1.08261872,
            1.32452315, 1.46025595, 1.26935527, 1.82824372, 1.8825282, 1.96655979, 2.15759734,
            2.04784671, 2.27481083, 2.75687308, 1.00893728, 0.89661938, 1.23842638, 1.38930768,
            0.82165779, 1.87730121, 1.40213434, 1.64245038, 1.88536446, 1.79153113, 1.76069807,
            2.47470884, 1.47368697, 1.17787832, 1.70684626, 2.03723779, 2.04339213, 2.38456016,
            0.90078831, 0.7236281, 0.87402038, 1.16980345, 0.95530991, 1.4241223, 1.57890671,
            1.23397031, 1.09010908, 1.41052559, 2.02773974, 1.44971376, 1.18276324, 1.18747866,
            1.35997138, 1.47104213, 1.51922177, 1.90492487, 1.30615548, 0.90849494, 0.89124148,
            1.33829776, 1.81949615, 1.13588267, 0.91726142, 0.84607577, 0.9969014, 1.10268179,
            1.1780249, 1.41717772, 1.62595902, 1.35596827, 2.08908236, 2.1989477, 2.01602661,
            2.74472954, 1.20964393, 0.8733053, 1.106624, 1.34610787, 1.26347855, 1.69306724,
            1.19504525, 1.10357579, 1.4928317, 1.58495288, 1.57233193, 2.00955759, 1.59222063,
            1.39499043, 1.8700194, 1.88888854, 2.08559243, 2.43344118, 1.82829158, 1.56775697,
            1.34094419, 1.49622085, 2.11084951, 1.82939309, 2.04687053, 1.82660819, 1.97711794,
            2.12164546, 2.24826985, 2.60142097, 1.58389339, 1.34871458, 1.53477051, 1.72212794,
            2.17965499, 1.86485976, 1.06939888, 1.29014414, 1.78930508, 1.72133869, 1.41013917,
            2.33763741, 1.80571425, 1.55907097, 1.87089979, 2.1076466, 2.12522113, 2.67126618,
            0.48724316, 0.57228018, 0.97380504, 0.82181194, 0.87130214, 1.0562351, 1.52103828,
            1.26912959, 1.59642576, 1.84828669, 1.39889632, 2.32006062, 2.00144676, 1.82199536,
            1.95730351, 2.19626199, 2.41983937, 2.63957551, 1.7146456, 1.37222987, 1.1329497,
            1.43387669, 2.09526586, 1.48893497, 1.91133755, 2.06513432, 2.20266089, 1.98346795,
            2.17105462, 2.94060866, 1.2377277, 1.41610972, 1.94586109, 1.60936735, 1.37114944,
            2.40376909, 1.15217243, 1.17998787, 1.87774285, 1.70837253, 1.5305277, 2.4220184,
            1.41817661, 1.13135247, 1.04435154, 1.52264512, 1.48358418, 1.52006233, 1.741109,
            1.46952861, 1.5842926, 1.96842641, 2.01633833, 2.40845479, 2.23315974, 1.90398364,
            2.04448377, 2.33077417, 2.58666511, 2.80956353, 1.88504674, 1.56544712, 1.8133957,
            2.11431785, 1.77759554, 2.79365136, 1.49446948, 1.43298457, 1.41370876, 1.68116573,
            1.52917037, 2.00546555, 1.37925787, 1.35442024, 1.42906257, 1.38003784, 1.8155451,
            1.70782159, 1.97916597, 1.38597134, 1.26155562, 1.82109038, 2.10156758, 2.13960447,
            1.74606969, 1.38730935, 1.64639179, 1.98534915, 1.73910821, 2.32935657, 1.68648089,
            1.56325578, 1.96216056, 2.12494381, 2.04491164, 2.60456158, 2.10432423, 2.05064821,
            2.09266466, 2.15623688, 2.26747089, 2.90070696, 1.96267144, 1.81548846, 2.23644747,
            2.26854023, 2.26362278, 2.76822632, 1.30911278, 1.21317012, 1.74191499, 1.84666809,
            1.82916726, 2.19809668, 1.12523562, 0.93032073, 1.07519986, 1.23857316, 1.23660008,
            1.46547442, 2.07987845, 1.74052359, 2.07251268, 2.36013268, 2.30673843, 2.8070215,
            1.35158675, 1.05116717, 1.54872975, 1.93476518, 1.75927052, 2.17034481, 1.47808247,
            1.28644333, 1.64892199, 1.78865634, 1.45324448, 2.40924825, 1.49943751, 1.3724881,
            1.59743893, 1.88881137, 1.61275273, 2.38534412, 1.62584369, 1.62443744, 1.98932387,
            1.90201746, 2.22244425, 2.61545705, 2.24047634, 2.0960581, 2.26891319, 2.48474234,
            2.3879243, 3.2434025, 2.01310566, 1.93230582, 2.20416771, 2.23448129, 2.19800399,
            3.15598494,
        ]
        .iter()
        .map(|e| Complex64::new(*e, 0.0))
        .collect();

        let d23 = vec![
            2.26365456, 1.91172196, 2.08069403, 1.726157, 2.33322809, 2.93347806, 3.30643076,
            1.7032021, 1.55205586, 2.01729225, 1.21126177, 1.46624606, 2.98335636, 1.61876502,
            2.37441403, 1.29641377, 3.02796936, 2.71097712, 1.86955235, 2.73524044, 1.86060305,
            2.03625939, 1.18173516, 2.00678881, 2.27088469, 2.2377288, 2.27255922, 2.10418327,
            2.3181827, 2.37278856, 1.28994567, 2.0984598, 2.17280842, 0.9493064, 2.41476094,
            2.62643989, 2.94812219, 2.16581855, 2.45443051, 3.2614984, 1.34726933, 2.61596042,
            2.59487354, 2.20836598, 2.65146475, 2.3835822, 2.8881242, 3.33244246, 3.74634223,
            1.69597655, 1.88584173, 2.3975717, 1.66377125, 1.77115172, 3.66518582, 2.10744574,
            2.91214106, 1.53886727, 3.61878857, 2.91382355, 2.57238061, 3.19586948, 2.02211238,
            2.59642176, 1.48274225, 2.54770281, 2.37008782, 2.50495023, 2.62184163, 2.47445717,
            2.65304178, 2.76579717, 1.55516676, 2.41593414, 2.50682297, 1.26753177, 2.6745018,
            2.94051307, 3.60417253, 2.41886092, 2.73869843, 3.83537906, 1.71177263, 2.99747718,
            2.78292851, 2.59909423, 2.76371306, 2.89661641, 2.82856224, 3.40501014, 3.75516628,
            1.41655435, 2.29707045, 2.76579604, 1.91089414, 2.17682666, 3.92695967, 2.43223726,
            3.23378262, 1.64302206, 3.82033519, 2.98630523, 2.82847693, 3.41160629, 1.82115419,
            2.69727454, 1.9513187, 2.92082688, 2.17272205, 2.76945309, 2.95754757, 2.69615064,
            2.84062786, 2.97615104, 2.14886486, 2.75705841, 3.12082609, 1.66301496, 2.8849343,
            3.23935657, 3.85263249, 2.76230575, 2.71449294, 4.17197157, 1.71225318, 3.2060212,
            2.30078623, 2.31603916, 2.47861888, 2.10963808, 2.61263874, 2.95718793, 3.60954837,
            2.00910309, 1.75939687, 2.3870422, 1.20833684, 2.17842582, 3.39445104, 1.95377094,
            2.93470269, 1.81266243, 3.26602762, 3.0177403, 2.5656522, 2.92604782, 1.50628753,
            2.35994593, 0.91734489, 1.92298386, 2.48586667, 2.57512368, 2.64945858, 2.13251017,
            2.37241574, 2.78953963, 1.61736592, 2.22235373, 2.2739628, 1.24215218, 2.03596923,
            2.81712057, 3.59229326, 2.08219757, 2.94123637, 3.66357688, 1.59873373, 2.80342731,
            2.55200381, 2.48831416, 2.63494441, 2.75473105, 2.44237122, 3.29804298, 3.63002577,
            1.42481135, 2.27271327, 2.65205658, 1.9641218, 2.08223906, 3.70261598, 2.28756914,
            3.21289916, 1.56513847, 3.50230811, 2.83129901, 2.70700826, 3.24281549, 1.8038223,
            2.54300916, 2.00837872, 2.84457191, 1.86060937, 2.56023337, 2.89664266, 2.45510599,
            2.80844591, 2.91850834, 2.12634616, 2.71020791, 3.05775594, 1.57386194, 2.9380653,
            3.16350012, 3.71660243, 2.77496295, 2.59615614, 4.03244012, 1.65221159, 3.17672444,
            2.85413148, 2.67084443, 2.13007991, 2.544576, 2.75579364, 3.09862199, 3.37282619,
            0.91962843, 2.01475222, 2.81689394, 1.77165204, 2.05799782, 3.48820546, 2.13165211,
            2.582218, 1.42617809, 3.60198409, 2.8263297, 2.23492897, 3.05915382, 1.44971956,
            2.60617169, 1.72509727, 2.85872219, 2.266664, 3.02302529, 2.77184747, 2.81724295,
            2.38132368, 2.66777055, 2.01858918, 2.72203873, 3.18896399, 1.54552205, 2.67569363,
            2.91093273, 3.13641088, 2.58063269, 2.52692356, 3.81776432, 1.39450393, 2.72818806,
            0.748308, 1.02652135, 0.81792432, 1.18394693, 0.7043945, 1.33016534, 1.44589553,
            0.4932908, 0.54199321, 0.87412282, 0.59645225, 0.69984637, 1.28296857, 0.76496061,
            1.21860567, 0.64913445, 1.2966851, 0.82322654, 1.06233028, 1.25451079, 0.44904484,
            1.00367858, 0.63086284, 1.16879426, 0.54438472, 0.81433299, 1.199346, 1.0468729,
            0.8074733, 0.75946005, 0.98448857, 0.64526581, 1.05437596, 0.89525863, 1.13595851,
            1.19416322, 1.3960031, 1.21712123, 0.95540607, 1.6020109, 0.62303777, 1.36323068,
            1.1508885, 1.45865565, 1.34996191, 1.9776342, 1.41601207, 1.96957158, 2.17418996,
            0.764663, 1.40703658, 1.42792494, 1.22164253, 1.17656304, 2.17378862, 1.44314856,
            1.89057026, 1.04560274, 1.85797286, 1.47633113, 1.76507702, 1.89120766, 1.05516236,
            1.59034005, 1.41224128, 1.79302828, 0.88255892, 1.69342825, 1.6969244, 1.76041468,
            1.85329114, 1.78973058, 1.58503011, 1.32703782, 1.92246812, 1.1643054, 1.87371921,
            2.08652256, 2.21970909, 1.63796983, 1.3987252, 2.57982744, 0.94663673, 2.02678841,
            3.01289872, 2.67433363, 2.71524746, 2.50450664, 3.21304546, 3.47279904, 3.98150839,
            1.57199048, 2.15096934, 2.9976246, 2.05927725, 2.2117877, 3.94782228, 2.28141596,
            3.05246249, 1.70312651, 3.88001747, 3.27291164, 2.72578421, 3.31379773, 1.92397969,
            3.02749941, 1.54251354, 2.87250728, 2.63290368, 3.13065959, 2.94489305, 2.72291001,
            2.73768355, 3.21756361, 1.69793175, 2.99888753, 3.00805604, 1.29633475, 2.79082227,
            3.06907053, 3.73003416, 2.54162999, 3.1145701, 4.15808655, 1.81828274, 3.01138166,
            3.2306467, 2.49844311, 2.84207856, 2.27024209, 3.42287337, 3.41624284, 3.89200148,
            1.90531793, 2.18077726, 2.76168323, 1.37934344, 2.18272854, 3.97318739, 2.2984647,
            2.93333134, 1.65674382, 4.125745, 3.6006321, 2.45568689, 3.46332658, 2.10163889,
            2.53415728, 1.38691612, 2.37217085, 3.19904949, 3.05862897, 2.78179441, 2.68408109,
            2.85234694, 3.10295455, 1.60618094, 2.87990847, 2.83146992, 1.18849508, 2.540845,
            3.18132693, 3.76070136, 2.41019991, 3.0602034, 3.98069486, 1.6450207, 2.95298981,
            1.84250424, 1.80424974, 2.04887192, 1.68484203, 1.79291675, 2.05212839, 2.47700945,
            1.15664633, 1.53750374, 2.03650965, 1.31813331, 1.80201375, 2.59955108, 1.57517371,
            2.3637977, 1.24922108, 2.42188178, 2.1215111, 2.06803019, 2.10683164, 0.95593396,
            1.84443552, 0.90617874, 1.66010316, 1.44903009, 1.77326986, 2.03675393, 1.32201802,
            1.69506664, 2.17369294, 1.21976918, 2.03192424, 1.88037612, 0.9090599, 1.49729774,
            1.91422603, 2.71063869, 1.59689434, 2.09078, 2.64923632, 1.26116955, 1.95612933,
            2.97883721, 2.4718446, 2.34822816, 1.97682159, 3.21460388, 3.18628796, 3.7272163,
            1.85394444, 2.2139935, 2.75904854, 1.43573258, 2.16921997, 3.61864729, 2.08190369,
            2.60376539, 1.64399529, 3.60196359, 3.58946857, 2.12644683, 3.10307089, 2.03707718,
            2.45493314, 1.36258822, 2.18891539, 3.13580203, 3.38963836, 2.64261517, 2.66979445,
            2.88119538, 3.28251719, 1.58189112, 2.92018746, 2.93253789, 0.95079855, 2.5215355,
            3.1412665, 3.34432864, 2.19655562, 3.01932893, 3.83757948, 1.4437028, 2.7167721,
            2.71085459, 2.41086444, 1.86614683, 1.95742858, 2.60399651, 2.54347429, 2.89381999,
            0.88106861, 2.1839793, 2.7932075, 1.78305508, 2.10210198, 3.09433963, 1.91799781,
            2.20589687, 1.29134544, 3.00612969, 2.88065176, 1.84467956, 2.51816849, 1.39478088,
            2.30492171, 1.57222755, 2.33741448, 2.23040487, 3.14443277, 2.39040328, 2.353139,
            2.36759745, 2.93251933, 1.63440994, 2.96131123, 3.06742543, 0.9515606, 2.26921302,
            2.58054285, 2.65762374, 2.00880959, 2.39712515, 3.30241028, 1.16944797, 2.13074947,
            1.65836776, 1.36633555, 1.65684129, 1.72576734, 1.64675565, 2.34009021, 2.44399289,
            1.1802075, 1.6342992, 1.42590193, 1.05878088, 1.02833017, 2.41336534, 1.48727666,
            1.96305976, 0.89403255, 2.29426245, 2.01151116, 1.47839023, 2.26628572, 1.73152178,
            1.34532475, 1.64421208, 1.75474686, 1.42187192, 1.68661626, 1.73173693, 1.79623346,
            2.29529636, 1.95340953, 1.41565509, 1.67900872, 2.05193864, 0.91431445, 2.2962957,
            2.40130644, 2.37428397, 1.92379842, 1.52133404, 2.66969845, 0.93961441, 2.25777921,
            2.60253489, 2.51970534, 2.17341733, 2.68394886, 2.99425133, 3.23237794, 3.61112309,
            1.24379894, 2.11942521, 2.63941796, 1.7804413, 1.97563694, 3.61767418, 2.22795027,
            2.65615905, 1.60604433, 3.50145458, 2.91212019, 2.45336269, 3.11435537, 1.77190538,
            2.71571227, 1.79088256, 2.77658797, 2.38466393, 3.21226044, 2.69789956, 3.01966027,
            2.76759455, 2.95293578, 2.04632251, 2.53611259, 3.09893268, 1.51010736, 2.78491575,
            3.16655214, 3.33662637, 2.4432147, 2.61615377, 4.02867578, 1.48620483, 2.91031708,
        ]
        .iter()
        .map(|e| Complex64::new(*e, 0.0))
        .collect();
        (d12, d23)
    }

    #[test]
    fn test_tensor_contraction() {
        // t1 is of shape [3, 2, 7]
        let mut t1 = Tensor::new(vec![0, 1, 2]);

        // t2 is of shape [7, 8, 6]
        let mut t2 = Tensor::new(vec![2, 3, 4]);
        // t3 is of shape [3, 5, 8]
        let mut t3 = Tensor::new(vec![0, 5, 3]);
        // tout is of shape [8, 6, 3, 2]
        let mut t12 = Tensor::new(vec![3, 4, 0, 1]);
        // tout is of shape [3, 5, 7, 6]
        let mut t23 = Tensor::new(vec![0, 5, 2, 4]);

        let bond_dims = HashMap::from([(0, 3), (1, 2), (2, 7), (3, 8), (4, 6), (5, 5)]);

        t1.insert_bond_dims(&bond_dims);
        t2.insert_bond_dims(&bond_dims);
        t3.insert_bond_dims(&bond_dims);

        t12.insert_bond_dims(&bond_dims);
        t23.insert_bond_dims(&bond_dims);

        let edges_before_contraction = HashMap::<_, _>::from_iter([
            (0, vec![Vertex::Closed(0), Vertex::Closed(2)]),
            (1, vec![Vertex::Closed(0), Vertex::Open]),
            (2, vec![Vertex::Closed(0), Vertex::Closed(1)]),
            (3, vec![Vertex::Closed(1), Vertex::Closed(2)]),
            (4, vec![Vertex::Closed(1), Vertex::Open]),
            (5, vec![Vertex::Closed(2), Vertex::Open]),
        ]);

        let edges_after_contraction_1 = HashMap::<_, _>::from_iter([
            (0, vec![Vertex::Closed(0), Vertex::Closed(2)]),
            (1, vec![Vertex::Closed(0), Vertex::Open]),
            (3, vec![Vertex::Closed(0), Vertex::Closed(2)]),
            (4, vec![Vertex::Closed(0), Vertex::Open]),
            (5, vec![Vertex::Closed(2), Vertex::Open]),
        ]);

        let edges_after_contraction_2 = HashMap::<_, _>::from_iter([
            (0, vec![Vertex::Closed(0), Vertex::Closed(1)]),
            (1, vec![Vertex::Closed(0), Vertex::Open]),
            (2, vec![Vertex::Closed(0), Vertex::Closed(1)]),
            (4, vec![Vertex::Closed(1), Vertex::Open]),
            (5, vec![Vertex::Closed(1), Vertex::Open]),
        ]);

        let (d1, d2, d3, _) = setup();

        t1.set_tensor_data(TensorData::new_from_data(
            &t1.shape(),
            d1,
            Some(Layout::RowMajor),
        ));

        t2.set_tensor_data(TensorData::new_from_data(
            &t2.shape(),
            d2,
            Some(Layout::RowMajor),
        ));
        t3.set_tensor_data(TensorData::new_from_data(
            &t3.shape(),
            d3,
            Some(Layout::RowMajor),
        ));

        let (ref12, ref23) = intermediate_data();
        t12.set_tensor_data(TensorData::new_from_data(
            &t12.shape(),
            ref12,
            Some(Layout::RowMajor),
        ));

        t23.set_tensor_data(TensorData::new_from_data(
            &t23.shape(),
            ref23,
            Some(Layout::RowMajor),
        ));

        let mut tn_12 =
            create_tensor_network(vec![t1.clone(), t2.clone(), t3.clone()], &bond_dims, None);
        assert_eq!(tn_12.edges(), &edges_before_contraction);
        tn_12.contract_tensors(0, 1);
        assert!(t12.approx_eq(tn_12.tensor(0), 1e-8));
        assert_eq!(tn_12.edges(), &edges_after_contraction_1);

        let mut tn_23 = create_tensor_network(vec![t1, t2, t3], &bond_dims, None);
        assert_eq!(tn_23.edges(), &edges_before_contraction);
        tn_23.contract_tensors(1, 2);
        assert!(t23.approx_eq(tn_23.tensor(1), 1e-8));
        assert_eq!(tn_23.edges(), &edges_after_contraction_2);
    }

    #[test]
    fn test_tn_contraction() {
        // t1 is of shape [3, 2, 7]
        let mut t1 = Tensor::new(vec![0, 1, 2]);

        // t2 is of shape [7, 8, 6]
        let mut t2 = Tensor::new(vec![2, 3, 4]);
        // t3 is of shape [3, 5, 8]
        let mut t3 = Tensor::new(vec![0, 5, 3]);
        // tout is of shape [5, 6, 2]
        let mut tout = Tensor::new(vec![5, 4, 1]);
        let bond_dims = HashMap::from([(0, 3), (1, 2), (2, 7), (3, 8), (4, 6), (5, 5)]);

        t1.insert_bond_dims(&bond_dims);
        t2.insert_bond_dims(&bond_dims);
        t3.insert_bond_dims(&bond_dims);

        tout.insert_bond_dims(&bond_dims);

        let edges_before_contraction = HashMap::<_, _>::from_iter([
            (0, vec![Vertex::Closed(0), Vertex::Closed(2)]),
            (1, vec![Vertex::Closed(0), Vertex::Open]),
            (2, vec![Vertex::Closed(0), Vertex::Closed(1)]),
            (3, vec![Vertex::Closed(1), Vertex::Closed(2)]),
            (4, vec![Vertex::Closed(1), Vertex::Open]),
            (5, vec![Vertex::Closed(2), Vertex::Open]),
        ]);

        let edges_after_contraction = HashMap::<_, _>::from_iter([
            (1, vec![Vertex::Closed(0), Vertex::Open]),
            (4, vec![Vertex::Closed(0), Vertex::Open]),
            (5, vec![Vertex::Closed(0), Vertex::Open]),
        ]);

        let (d1, d2, d3, dout) = setup();

        t1.set_tensor_data(TensorData::new_from_data(
            &t1.shape(),
            d1,
            Some(Layout::RowMajor),
        ));

        t2.set_tensor_data(TensorData::new_from_data(
            &t2.shape(),
            d2,
            Some(Layout::RowMajor),
        ));
        t3.set_tensor_data(TensorData::new_from_data(
            &t3.shape(),
            d3,
            Some(Layout::RowMajor),
        ));
        tout.set_tensor_data(TensorData::new_from_data(
            &tout.shape(),
            dout,
            Some(Layout::RowMajor),
        ));

        let mut tn = create_tensor_network(vec![t1, t2, t3], &bond_dims, None);
        let contract_path = path![(0, 1), (0, 2)];
        assert_eq!(tn.edges(), &edges_before_contraction);
        contract_tensor_network(&mut tn, contract_path);
        assert!(tout.approx_eq(&tn, 1e-8));
        assert_eq!(tn.edges(), &edges_after_contraction);
    }

    #[test]
    fn test_outer_product_contraction() {
        let mut t1 = Tensor::new(vec![0]);
        let mut t2 = Tensor::new(vec![1]);
        t1.set_tensor_data(TensorData::new_from_data(
            &[3],
            vec![
                Complex64::new(1.0, 0.0),
                Complex64::new(2.0, 5.0),
                Complex64::new(3.0, -1.0),
            ],
            None,
        ));
        t2.set_tensor_data(TensorData::new_from_data(
            &[2],
            vec![Complex64::new(-4.0, 2.0), Complex64::new(0.0, -1.0)],
            None,
        ));
        let mut t3 = Tensor::default();
        let bond_dims = HashMap::from([(0, 3), (1, 2)]);
        t3.push_tensors(vec![t1, t2], Some(&bond_dims), None);
        let contract_path = path![(0, 1)];

        let mut tn_ref = Tensor::new(vec![1, 0]);
        tn_ref.insert_bond_dims(&bond_dims);
        tn_ref.set_tensor_data(TensorData::new_from_data(
            &[2, 3],
            vec![
                Complex64::new(-4.0, 2.0),
                Complex64::new(0.0, -1.0),
                Complex64::new(-18.0, -16.0),
                Complex64::new(5.0, -2.0),
                Complex64::new(-10.0, 10.0),
                Complex64::new(-1.0, -3.0),
            ],
            None,
        ));

        contract_tensor_network(&mut t3, contract_path);
        assert!(t3.approx_eq(&tn_ref, 1e-8));
    }
}
